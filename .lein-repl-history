    (pprint paths)
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
cases
(:chests (first cases))
(defn parseCase
  [{:keys [index value]}]
  (let
    [lines (rest value)
     keysList (map to-int (split (first lines) #"\s"))
     chests (for [chest (rest lines)]
                 (let
                   [[lockType numKeys & keysInside] (map to-int (split chest #"\s"))]
                   {:lockType lockType
                    :keysInside keysInside}))]
    {:caseNumber index
     :keysList keysList
     :chests (apply sorted-set-by (fn [l r] (compare (:index l) (:index r)))
                                      (indexed-values chests))}))
(def caseParser (partial parse-cases-from-input parseCase linesPerCase))
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(test-expected-output solve-for-input problemName "sample")
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(:chests (first cases))
(contains? (:chests (first cases)) {:index 1})
(disj (:chests (first cases)) {:index 1})
(disj (:chests (first cases)) {:index 4})
(disj (:chests (first cases)) {:index 3})
(disj (:chests (first cases)) {:index 2})
(test-expected-output solve-for-input problemName "sample")
(def ls (cons 4 (cons 5 (lazy-seq [(empty? `(1))]))))
(def lastls (last ls))
(if lastls true false)
ls
(defn find-paths
  [keysHeld chests]
  (if (empty? keysHeld)
      (lazy-seq [(empty? chests)])
      (for [{:keys [index value] :as chest} chests]
      (let
        [{:keys [lockType keysInside]} value]
        (if (keysHeld lockType)
          (let
            [keysHeld (removeKeyHeld keysHeld lockType)
             keysHeld (addToKeysHeld keysHeld keysInside)
             chests (disj chests chest)]
            (cons index (flatten find-paths keysHeld chests))))))))
(test-expected-output solve-for-input problemName "sample")
(defn find-paths
  [keysHeld chests]
  (if (empty? keysHeld)
      (lazy-seq [(empty? chests)])
      (for [{:keys [index value] :as chest} chests]
      (let
        [{:keys [lockType keysInside]} value]
        (if (keysHeld lockType)
          (let
            [keysHeld (removeKeyHeld keysHeld lockType)
             keysHeld (addToKeysHeld keysHeld keysInside)
             chests (disj chests chest)]
            (cons index (flatten (find-paths keysHeld chests)))))))))
(test-expected-output solve-for-input problemName "sample")
(defn find-paths
  [keysHeld chests]
  (if (empty? keysHeld)
      (lazy-seq [(empty? chests)])
      (map (fn [{:keys [index value] :as chest}]
             (let
              [{:keys [lockType keysInside]} value]
              (if (keysHeld lockType)
                (let
                  [keysHeld (removeKeyHeld keysHeld lockType)
                   keysHeld (addToKeysHeld keysHeld keysInside)
                   chests (disj chests chest)]
                  (cons index (find-paths keysHeld chests))))))
           chests)))
(test-expected-output solve-for-input problemName "sample")
(defn find-paths
  [keysHeld chests]
  (if (empty? keysHeld)
      (lazy-seq [(empty? chests)])
      (map (fn [{:keys [index value] :as chest}]
             (let
              [{:keys [lockType keysInside]} value]
              (if (keysHeld lockType)
                (let
                  [keysHeld (removeKeyHeld keysHeld lockType)
                   keysHeld (addToKeysHeld keysHeld keysInside)
                   chests (disj chests chest)]
                  (cons index (find-paths keysHeld chests))))))
           chests)))
(test-expected-output solve-for-input problemName "sample")
(defn find-paths
  [keysHeld chests]
  (if (empty? keysHeld)
      (lazy-seq [(empty? chests)])
      (map (fn [{:keys [index value] :as chest}]
             (let
              [{:keys [lockType keysInside]} value]
              (if (keysHeld lockType)
                (let
                  [keysHeld (removeKeyHeld keysHeld lockType)
                   keysHeld (addToKeysHeld keysHeld keysInside)
                   chests (disj chests chest)]
                  (cons index (flatten (find-paths keysHeld chests)))))))
           chests)))
(test-expected-output solve-for-input problemName "sample")
(defn find-paths
  [keysHeld chests]
  (if (empty? keysHeld)
      (lazy-seq [(empty? chests)])
      (map (fn [{:keys [index value] :as chest}]
             (let
              [{:keys [lockType keysInside]} value]
              (if (keysHeld lockType)
                (let
                  [keysHeld (removeKeyHeld keysHeld lockType)
                   keysHeld (addToKeysHeld keysHeld keysInside)
                   chests (disj chests chest)]
                  (cons index (find-paths keysHeld chests))))))
           chests)))
(defn find-paths
  [keysHeld chests]
  (if (empty? keysHeld)
      (lazy-seq [(empty? chests)])
      (map (fn [{:keys [index value] :as chest}]
             (let
              [{:keys [lockType keysInside]} value]
              (if (keysHeld lockType)
                (let
                  [keysHeld (removeKeyHeld keysHeld lockType)
                   keysHeld (addToKeysHeld keysHeld keysInside)
                   chests (disj chests chest)]
                  (cons index (find-paths keysHeld chests))))))
           chests)))
(test-expected-output solve-for-input problemName "sample")
(defn find-paths
  [keysHeld chests]
  (if (empty? keysHeld)
      (lazy-seq [(empty? chests)])
      (mapcat (fn [{:keys [index value] :as chest}]
             (let
              [{:keys [lockType keysInside]} value]
              (if (keysHeld lockType)
                (let
                  [keysHeld (removeKeyHeld keysHeld lockType)
                   keysHeld (addToKeysHeld keysHeld keysInside)
                   chests (disj chests chest)]
                  (cons index (find-paths keysHeld chests))))))
           chests)))
(test-expected-output solve-for-input problemName "sample")
(defn find-paths
  [keysHeld chests]
  (if (empty? keysHeld)
      (lazy-seq [(empty? chests)])
      (mapcat (fn [{:keys [index value] :as chest}]
             (let
              [{:keys [lockType keysInside]} value]
              (if (keysHeld lockType)
                (let
                  [keysHeld (removeKeyHeld keysHeld lockType)
                   keysHeld (addToKeysHeld keysHeld keysInside)
                   chests (disj chests chest)
                   paths (find-paths keysHeld chests)]
                  (if (seq paths)
                    (cons index (find-paths keysHeld chests))
                    nil)))))
           chests)))
(test-expected-output solve-for-input problemName "sample")
(defn find-paths
  [keysHeld chests]
  (if (empty? keysHeld)
      (lazy-seq [(empty? chests)])
      (mapcat (fn [{:keys [index value] :as chest}]
             (let
              [{:keys [lockType keysInside]} value]
              (if (keysHeld lockType)
                (let
                  [keysHeld (removeKeyHeld keysHeld lockType)
                   keysHeld (addToKeysHeld keysHeld keysInside)
                   chests (disj chests chest)
                   paths (find-paths keysHeld chests)]
                  (if (seq paths)
                    (cons index (find-paths keysHeld chests))
                    nil)))))
           chests)))
(test-expected-output solve-for-input problemName "sample")
(defn find-paths
  [keysHeld chests]
  (if (empty? keysHeld)
      (lazy-seq [(empty? chests)])
      (mapcat (fn [{:keys [index value] :as chest}]
             (let
              [{:keys [lockType keysInside]} value]
              (if (keysHeld lockType)
                (let
                  [keysHeld (removeKeyHeld keysHeld lockType)
                   keysHeld (addToKeysHeld keysHeld keysInside)
                   chests (disj chests chest)
                   paths (find-paths keysHeld chests)]
                  (if (seq paths)
                    (cons index (find-paths keysHeld chests))
                    nil)))))
           chests)))
(test-expected-output solve-for-input problemName "sample")
(defn find-paths
  [keysHeld chests]
  (if (empty? keysHeld)
      (if (empty? chests)
        (lazy-seq [false])
        nil)
      (mapcat (fn [{:keys [index value] :as chest}]
             (let
              [{:keys [lockType keysInside]} value]
              (if (keysHeld lockType)
                (let
                  [keysHeld (removeKeyHeld keysHeld lockType)
                   keysHeld (addToKeysHeld keysHeld keysInside)
                   chests (disj chests chest)
                   paths (find-paths keysHeld chests)]
                  (if (seq paths)
                    (cons index (find-paths keysHeld chests))
                    nil)))))
           chests)))
(test-expected-output solve-for-input problemName "sample")
(defn processCase
  [{:keys [caseNumber keysList chests]}]
  (let
    [keysHeld (addToKeysHeld {} keysList)
     paths (find-paths keysHeld chests)
     bestPath (take-while #(%) paths)
     validPaths (filter last paths)
     result ""]
    (pprint paths)
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn processCase
  [{:keys [caseNumber keysList chests]}]
  (let
    [keysHeld (addToKeysHeld {} keysList)
     paths (find-paths keysHeld chests)
     bestPath (take-while #(%) paths)
     validPaths (filter last paths)
     result ""]
    (pprint bestPath)
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn processCase
  [{:keys [caseNumber keysList chests]}]
  (let
    [keysHeld (addToKeysHeld {} keysList)
     paths (find-paths keysHeld chests)
     bestPath (take-while identity paths)
     validPaths (filter last paths)
     result ""]
    (pprint bestPath)
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn processCase
  [{:keys [caseNumber keysList chests]}]
  (let
    [keysHeld (addToKeysHeld {} keysList)
     paths (find-paths keysHeld chests)
     bestPath (take-while identity paths)
     validPaths (filter last paths)
     result (join " " bestPath)]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn processCase
  [{:keys [caseNumber keysList chests]}]
  (let
    [keysHeld (addToKeysHeld {} keysList)
     paths (find-paths keysHeld chests)
     bestPath (take-while identity paths)
     validPaths (filter last paths)
     result (if (seq bestPath)
              (join " " bestPath)
              "IMPOSSIBLE")]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(load-file (str "target/cljx_generated/clj/problems/treasure/main.clj"))
(in-ns 'problems.treasure.main)
(test-expected-output solve-for-input problemName "sample")
(def cases (caseParser (read-input-text problemName "small")))
(pprint cases)
(load-file (str "target/cljx_generated/clj/problems/treasure/main.clj"))
(in-ns 'problems.treasure.main)
(def cases (caseParser (read-input-text problemName "small")))
(pprint cases)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def cases (caseParser (read-input-text problemName "small")))
(pprint cases)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def cases (caseParser (read-input-text problemName "small")))
(pprint cases)
     validPaths (filter last paths)(defn find-paths
  [keysHeld chests]
  (if (or (empty? keysHeld) (empty? chests))
      (if (empty? chests)
        (lazy-seq [false])
        nil)
      (mapcat (fn [{:keys [index value] :as chest}]
             (let
              [{:keys [lockType keysInside]} value]
              (if (keysHeld lockType)
                (let
                  [keysHeld (removeKeyHeld keysHeld lockType)
                   keysHeld (addToKeysHeld keysHeld keysInside)
                   chests (disj chests chest)
                   paths (find-paths keysHeld chests)]
                  (if (seq paths)
                    (cons index (find-paths keysHeld chests))
                    nil)))))
           chests)))
(test-expected-output solve-for-input problemName "sample")
(println (write-solution solve-for-input problemName "small"))
(load-file (str "target/cljx_generated/clj/problems/treasure/main.clj"))
(in-ns 'problems.treasure.main)
(test-expected-output solve-for-input problemName "sample")
(println (write-solution solve-for-input problemName "small"))
(def cases (caseParser (read-input-text problemName "small")))
(pprint cases)
(defn find-paths
  [keysHeld chests]
  (if (empty? keysHeld)
      (if (empty? chests)
        (lazy-seq [false])
        nil)
      (mapcat (fn [{:keys [index value] :as chest}]
             (let
              [{:keys [lockType keysInside]} value]
              (if (keysHeld lockType)
                (let
                  [keysHeld (removeKeyHeld keysHeld lockType)
                   keysHeld (addToKeysHeld keysHeld keysInside)
                   chests (disj chests chest)
                   paths (find-paths keysHeld chests)]
                  (if (seq paths)
                    (cons index (find-paths keysHeld chests))
                    nil)))))
           chests)))
(test-expected-output solve-for-input problemName "sample")
(println (write-solution solve-for-input problemName "small"))
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(defn parseCase
  [{:keys [index value]}]
  (let
    [lines (rest value)
     keysList (map to-int (split (first lines) #"\s"))
     chests (for [chest (rest lines)]
                 (let
                   [[lockType numKeys & keysInside] (map to-int (split chest #"\s"))]
                   {:lockType lockType
                    :keysInside keysInside}))]
    {:caseNumber index
     :keysList keysList
     :chests (apply sorted-set-by (fn [l r] (compare (:index r) (:index l)))
                                      (indexed-values chests))}))
(def caseParser (partial parse-cases-from-input parseCase linesPerCase))
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(test-expected-output solve-for-input problemName "sample")
(load-file (str "target/cljx_generated/clj/problems/treasure/main.clj"))
(in-ns 'problems.treasure.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(load-file (str "target/cljx_generated/clj/problems/fair_and_square/main.clj"))
(in-ns 'problems.fair_and_square.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(Math/sqrt 999)
(Math/sqrt 989)
(Math/sqrt 981)
(* 31 31)
(* 33 33)
(* 29 29)
(* 22 22)
(* 1111 1111)
(* 2222 2222)
(* 3333 3333)
(Math/sqrt 1111)
(/ 1111 11)
(/ 2222 11)
(/ 3333 11)
(* 200 11)
(* 2200 2200)
(* 11 11)
(* 111 111)
(* 121 121)
(* 212 212)
(/ 212 11)
(* 303 303)
(* 313 313)
(* 222 222)
(* 212 212)
(* 2322 232)
(* 232 232)
(* 242 242)
(* 121 121)
(* 1221 1221)
(* 121 121)
(* 101 101)
(* 202 202)
(* 1111 1111)
(* 1001 1001)
(* 2002 2002)
(* 3003 3003)
(* 2002 2002)
(* 2112 2112)
(* 22 22)
(* 20102 20102)
(* 131 131)
(* 141 141)
(* 151 151)
(* 151 161)
(* 161 161)
(* 191 191)
(* 202 191)
(* 202 202)
(defn sq [n] (* n n))
(sq 202)
(sq 212)
(sq 222)
(sq 232)
(sq 1001)
(sq 1111)
(sq 1221)
(sq 1331)
(sq 1441)
(sq 2002)
(sq 2112)
(sq 10001)
(sq 10101)
(sq 11011)
(sq 11111)
(sq 20002)
(sq 20102)
(sq 20202)
(sq 20102)
(sq 10201)
(sq 12021)
(sq 12221)
(sq 11211)
(sq 20002)
(sq 20102)
(sq 22022)
(sq 22122)
(load-file (str "target/cljx_generated/clj/problems/lawnmower/main.clj"))
(in-ns 'problems.lawnmower.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (nth cases 2)))
(def cases (caseParser (read-input-text problemName "small")))
(pprint cases)
(load-file (str "target/cljx_generated/clj/problems/tic_tac_toe_tomek/main.clj"))
(in-ns 'problems.tic_tac_toe_tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def cases (caseParser (read-input-text problemName "small")))
(pprint cases)
(if (seq "hello") true false)
(if (seq "") true false)
(load-file (str "target/cljx_generated/clj/problems/tic_tac_toe_tomek/main.clj"))
(in-ns 'problems.tic_tac_toe_tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def cases (caseParser (read-input-text problemName "small")))
(pprint cases)
(def cases (caseParser (read-input-text problemName "small")))
(pprint cases)
(load-file (str "target/cljx_generated/clj/problems/tic_tac_toe_tomek/main.clj"))
(in-ns 'problems.tic_tac_toe_tomek.main)
(def cases (caseParser (read-input-text problemName "small")))
(pprint cases)
(def cases (caseParser (read-input-text problemName "small")))
(pprint cases)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def cases (caseParser (read-input-text problemName "small")))
(pprint cases)
(def largeSolution (write-solution solve-for-input problemName "large"))
