(def caseParser (partial parse-cases-from-input parseCase linesPerCase))
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(:board (first cases))
(defn parseCase
  [{:keys [index value]}]
  (let
    [[line1 line2 line3 line4 line5] value
     lineToVec (fn [line]
                 (vec line))
     board (vec (map lineToVec [line1 line2 line3 line4]))]
    {:caseNumber index
     :board board}))
(def caseParser (partial parse-cases-from-input parseCase linesPerCase))
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(:board (first cases))
(defn parseCase
  [{:keys [index value]}]
  (let
    [[line1 line2 line3 line4 line5] value
     board (vec (map vec [line1 line2 line3 line4]))]
    {:caseNumber index
     :board board}))
(def caseParser (partial parse-cases-from-input parseCase linesPerCase))
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(:board (first cases))
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def board (:board (first cases)))
board
(board 1)
(board 0)
((board 0) 1)
((board 0(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))) 1)
(in-ns 'problems.tic-tac-toe-tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
[0..3]
(range 3)
(defn rowsToCols
  [rows]
  (for [rowIndex (range 4)
        row rows]
    (row rowIndex)))
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    cols (rowsToCols rows)
    [result cols]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     result cols]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     result (pprint cols)]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn processCase(defn rowsToCols
  [rows]
  (for [rowIndex (range 4)]
    (for [row rows]
      (row rowIndex))))
(test-expected-output solve-for-input problemName "sample")
)
(defn rowsToCols
  [rows]
  (for [rowIndex (range 4)]
    (for [row rows]
      (row rowIndex))))
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     result (pprint cols)]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn rowsToCols
  [rows]
  (vec (for [rowIndex (range 4)]
    (vec (for [row rows]
      (row rowIndex))))))
(test-expected-output solve-for-input problemName "sample")
(defn diagonalsFromBoard
  [rows]
  (vec (for [rowIndex (range 4)]
         ((rows rowIndex) rowIndex))))
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     diagonals (diagonalsFromBoard rows)
     result (pprint diagonals)]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn diagonalsFromBoard
  [rows]
  (vec (for [rowIndex (range 4)]
         (concat (vec ((rows rowIndex) rowIndex))
                 (vec ((rows rowIndex) (- 3 rowIndex)))))))
(test-expected-output solve-for-input problemName "sample")
(defn diagonalsFromBoard
  [rows]
  (vec (for [rowIndex (range 4)]
         [((rows rowIndex) rowIndex)
          ((rows rowIndex) (- 3 rowIndex))])))
(test-expected-output solve-for-input problemName "sample")
(defn diagonalsFromBoard
  [rows]
  [(vec (for [rowIndex (range 4)]
         ((rows rowIndex) rowIndex)))
   (vec (for [rowIndex (range 4)]
         ((rows rowIndex) (- 3 rowIndex))))])
(test-expected-output solve-for-input problemName "sample")
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     diagonals (diagonalsFromBoard rows)
     possibleWins (concat rows cols diagonals)
     result (pprint diagonals)]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     diagonals (diagonalsFromBoard rows)
     possibleWins (concat rows cols diagonals)
     result (pprint possibleWins)]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn xWinFilter
  [possibleWin]
  (every? %(or (= % \X) (= % \T)) possibleWin))
(defn xWinFilter
  [possibleWin]
  (every? #(or (= % \X) (= % \T)) possibleWin))
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     diagonals (diagonalsFromBoard rows)
     possibleWins (concat rows cols diagonals)
     xWins (filter xWinFilter possibleWins)
     result (pprint possibleWins)]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     diagonals (diagonalsFromBoard rows)
     possibleWins (concat rows cols diagonals)
     xWins (filter xWinFilter possibleWins)
     result (pprint (empty? xWins))]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     diagonals (diagonalsFromBoard rows)
     possibleWins (concat rows cols diagonals)
     xWins (filter xWinFilter possibleWins)
     result (empty? xWins)]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     diagonals (diagonalsFromBoard rows)
     possibleWins (concat rows cols diagonals)
     xWins (filter (partial xWinFilter \X) possibleWins)
     result (empty? xWins)]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     diagonals (diagonalsFromBoard rows)
     possibleWins (concat rows cols diagonals)
     xWins (filter (partial winFilter \X) possibleWins)
     result (empty? xWins)]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(defn winFilter
  [symb possibleWin]
  (every? #(or (= % symb) (= % \T)) possibleWin))
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     diagonals (diagonalsFromBoard rows)
     possibleWins (concat rows cols diagonals)
     xWins (filter (partial winFilter \X) possibleWins)
     result (empty? xWins)]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn boardFull?
  [rows]
  (for [row rows]
    (every? #(not= % \.) row)))
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     diagonals (diagonalsFromBoard rows)
     possibleWins (concat rows cols diagonals)
     xWins (filter (partial winFilter \X) possibleWins)
     yWins (filter (partial winFilter \Y) possibleWins)
     boardFull (boardFull? rows)
     result boardFull]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn boardFull?
  [rows]
  (every? (for [row rows]
    (every? #(not= % \.) row))))
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     diagonals (diagonalsFromBoard rows)
     possibleWins (concat rows cols diagonals)
     xWins (filter (partial winFilter \X) possibleWins)
     yWins (filter (partial winFilter \Y) possibleWins)
     boardFull (boardFull? rows)
     result boardFull]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn boardFull?
  [rows]
  (every? #(%) (for [row rows]
    (every? #(not= % \.) row))))
(test-expected-output solve-for-input problemName "sample")
(defn boardFull?
  [rows]
  (every? #(not= \.)
          (for [row rows
                symb row]
               symb)))
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     diagonals (diagonalsFromBoard rows)
     possibleWins (concat rows cols diagonals)
     xWins (filter (partial winFilter \X) possibleWins)
     yWins (filter (partial winFilter \Y) possibleWins)
     boardFull (boardFull? rows)
     result boardFull]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
(test-expected-output solve-for-input problemName "sample")
(defn boardFull?
  [rows]
  (every? #(not= \. %)
          (for [row rows
                symb row]
               symb)))
(test-expected-output solve-for-input problemName "sample")
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     diagonals (diagonalsFromBoard rows)
     possibleWins (concat rows cols diagonals)
     xWon (seq (filter (partial winFilter \X) possibleWins))
     yWon (seq (filter (partial winFilter \Y) possibleWins))
     boardFull (boardFull? rows)
     result (cond xWon "X won"
                  yWon "Y won")]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     diagonals (diagonalsFromBoard rows)
     possibleWins (concat rows cols diagonals)
     xWon (seq (filter (partial winFilter \X) possibleWins))
     yWon (seq (filter (partial winFilter \Y) possibleWins))
     boardFull (boardFull? rows)
     result (cond (or xWon yWon) (if xWon) "X won" "Y won")]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     diagonals (diagonalsFromBoard rows)
     possibleWins (concat rows cols diagonals)
     xWon (seq (filter (partial winFilter \X) possibleWins))
     yWon (seq (filter (partial winFilter \Y) possibleWins))
     boardFull (boardFull? rows)
     result (cond (or xWon yWon) (if xWon "X won" "Y won"))]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(defn processCase
  [{:keys [caseNumber rows]}]
  (let
    [cols (rowsToCols rows)
     diagonals (diagonalsFromBoard rows)
     possibleWins (concat rows cols diagonals)
     xWon (seq (filter (partial winFilter \X) possibleWins))
     oWon (seq (filter (partial winFilter \O) possibleWins))
     boardFull (boardFull? rows)
     result (cond (or xWon oWon) (if xWon "X won" "O won")
                  boardFull "Draw"
                  :else "Game has not completed")]
    ^:clj (print-status (str "Completed Case #" caseNumber))
    {:caseNumber caseNumber
     :result     result}))
(test-expected-output solve-for-input problemName "sample")
(println (write-solution solve-for-input problemName "small"))
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(test-expected-output solve-for-input problemName "sample")
(println (write-solution solve-for-input problemName "small"))
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
(test-expected-output solve-for-input problemName "sample")
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
(test-expected-output solve-for-input problemName "sample")
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
(test-expected-output solve-for-input problemName "sample")
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
(test-expected-output solve-for-input problemName "sample")
(println (write-solution solve-for-input problemName "small"))
(test-expected-output solve-for-input problemName "sample")
(println (write-solution solve-for-input problemName "small"))
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
(test-expected-output solve-for-input problemName "sample")
(println (write-solution solve-for-input problemName "small"))
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(println (write-solution solve-for-input problemName "small"))
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
(test-expected-output solve-for-input problemName "sample")
(println (write-solution solve-for-input problemName "small"))
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(test-expected-output solve-for-input problemName "sample")
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(test-expected-output solve-for-input problemName "sample")
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
(test-expected-output solve-for-input problemName "sample")
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
(def hey (comp not empty?))
(hey "hello")
(hey "")
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def rows (:rows (first cases)))
;<F5> Parse and print sample
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(load-file (str "target/cljx_generated/clj/problems/tic-tac-toe-tomek/main.clj"))
(in-ns 'problems.tic-tac-toe-tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
ls
..
(load-file (str "target/cljx_generated/clj/problems/tic_tac_toe_tomek/main.clj"))
(in-ns 'problems.tic_tac_toe_tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(load-file (str "target/cljx_generated/clj/problems/tic_tac_toe_tomek/main.clj"))
(in-ns 'problems.tic_tac_toe_tomek.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(test-expected-output solve-for-input problemName "sample")
(println (write-solution solve-for-input problemName "small"))
(load-file (str "target/cljx_generated/clj/problems/lawnmower/main.clj"))
(in-ns 'problems.lawnmower.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
(load-file (str "target/cljx_generated/clj/problems/lawnmower/main.clj"))
(in-ns 'problems.lawnmower.main)
(load-file (str "target/cljx_generated/clj/problems/lawnmower/main.clj"))
(in-ns 'problems.lawnmower.main)
(def cases (caseParser (read-input-text problemName "sample")))
(pprint cases)
